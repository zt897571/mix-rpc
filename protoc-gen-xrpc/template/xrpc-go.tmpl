// Code generated by protoc-gen-go-xrpc. DO NOT EDIT.
// source file: {{.FileName}}
// template: xrpc-go.tmpl

package xrpc

import (
     "github.com/gogo/protobuf/proto"
	 "golang/error_code"
     "golang/iface"
     xgame "golang/proto"
     "time"
)
{{range $index, $service := .Services}}
{{if .IsActor}}
type I{{.Name}} interface {
    {{- range .Methods}}
    Call{{.Name}}(iface.IPid, *{{.InputType}}, time.Duration) (*{{.OutputType}}, error)
    {{- end}}
}

type I{{.Name}}Handler interface {
    {{- range .Methods}}
    OnCall{{.Name}}(iface.IPid, *{{.InputType}}) (*{{.OutputType}}, error)
    OnCast{{.Name}}(iface.IPid, *{{.InputType}}) (error)
    {{- end}}
}

type {{.Name}} struct {
    iface.IProcess
}

func New{{.Name}}(process iface.IProcess) *{{.Name}} {
    return &{{.Name}}{IProcess: process}
}

{{range .Methods}}
func (s *{{$service.Name}}) Call{{.Name}}(pid iface.IPid, req *{{.InputType}}, timeout time.Duration) (*{{.OutputType}}, error) {
    reply, err := s.Call(pid, req, timeout)
    if err != nil{
        return nil, err
    }
    if msg, ok := reply.(*{{.OutputType}}); ok{
        return msg, nil
    } else {
        return nil, error_code.MsgTypeError
    }
}
{{end}}

{{range .Methods}}
func Call{{.Name}}(pid iface.IPid, req *{{.InputType}}, timeout time.Duration) (*{{.OutputType}}, error) {
    reply, err := Call(pid, req, timeout)
    if err != nil{
        return nil, err
    }
    if msg, ok := reply.(*{{.OutputType}}); ok{
        return msg, nil
    } else {
        return nil, error_code.MsgTypeError
    }
}
{{end}}

{{- else -}}
type I{{$service.Name}}Handler interface {
    GetModuleName() string
    {{- range .Methods}}
    OnCall{{.Name}}(*{{.InputType}}) (*{{.OutputType}}, error)
    OnCast{{.Name}}(*{{.InputType}}) (error)
    {{- end}}
}

{{range .Methods}}
func Call{{.Name}}(node string, module string, req *{{.InputType}}, timeout time.Duration) (*{{.OutputType}}, error) {
    mfa, err := BuildMfa(module, "OnCall{{.Name}}", req)
    if err != nil {
        return nil, err
    }
    reply, err := NodeCall(node, mfa, timeout)
    if err != nil {
        return nil, err
    }
    if msg, ok := reply.(*{{.OutputType}}); ok{
        return msg, nil
    }else {
        return nil, error_code.MsgTypeError
    }
}

func Cast{{.Name}}(node string, module string, req *{{.InputType}}) error {
    mfa, err := BuildMfa(module, "OnCast{{.Name}}", req)
    if err != nil {
        return err
    }
    return NodeCast(node, mfa)
}
{{end}}

func Dispatch{{$service.Name}}CallMsg(handler I{{$service.Name}}Handler, msgName string, msg proto.Message) (proto.Message, error) {
    switch msgName {
    {{- range .Methods}}
    case "OnCall{{.Name}}":
        return handler.OnCall{{.Name}}(msg.(*{{.InputType}}))
    {{- end}}
    }
    log.Error("Dispatch{{$service.Name}}CallMsg not found msgName:%s", msgName)
    return nil, error_code.MsgHandlerNotFound
}

func Dispatch{{$service.Name}}CastMsg(handler I{{$service.Name}}Handler, msgName string, msg proto.Message)  error {
    switch msgName {
    {{- range .Methods}}
    case "OnCast{{.Name}}":
        return handler.OnCast{{.Name}}(msg.(*{{.InputType}}))
    {{- end}}
    }
    log.Error("Dispatch{{$service.Name}}CallMsg not found msgName:%s", msgName)
    return error_code.MsgHandlerNotFound
}

{{end}}
{{end}}